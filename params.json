{
  "name": "One",
  "tagline": "Browser side caching utility. It guarantees entity uniqueness in the cache.",
  "body": "# One\r\n\r\nEach entity tracked for uniqueness must have a unique id. There is precisely ONE distinct entity in the cache \r\nfor each unique id. Entities that do not have a unique id are still cached but not tracked for uniqueness.\r\n\r\n###Api\r\nThere are three significant operation types to be aware of:\r\n* **[put](https://maierson.gitbooks.io/one/content/put.html) / [get](https://maierson.gitbooks.io/one/content/get.html) / [evict](https://maierson.gitbooks.io/one/content/evict.html)** - items go into the cache with a ```put``` operation and come out with a ```get``` call. Use ```evict``` to force items out of the cache.\r\n* **[queue](https://maierson.gitbooks.io/one/content/queue.html)** - fast input to bypass uniqueness tracking\r\n* **[time travel](https://maierson.gitbooks.io/one/content/time_travel.html)** - ```undo()``` and ```redo()``` to go back and forth in time\r\n\r\nSome code\r\n\r\n    let item1 = {uid:1}\r\n    let item2 = {uid:2, ref:item1}\r\n    One.put(item2)\r\n    \r\n    // puts all items with uid separately in the cache\r\n    \r\n    One.get(item1) === undefined // false (item1 is added from item2)\r\n    item1 === One.get(item1) // true (same object)\r\n    item2.ref === One.get(1) // true\r\n\r\n\r\n###Threading\r\n```One``` can place entities on separate [threads](https://maierson.gitbooks.io/one/content/threads.html) for a granular control of the time travelling mechanism.\r\n\r\n###Immutable \r\nAll data is immutable. Once an item enters the cache it freezes and cannot change. This is to enable quick identity checks against immutable entities (ie React identity check). \r\n\r\n    let item = {uid:1}\r\n    Object.isFrozen(item) // false\r\n    \r\n    One.put(item);\r\n    Object.isFrozen(item) // true\r\n    \r\n    let result = One.get(item)\r\n    result === item // true\r\n\r\nIf you later want to edit a reference of the object you can get an editable copy from the cache. This gives you a separate clone of the object that is now editable:\r\n\r\n    let item = {uid:1}\r\n    One.put(item)\r\n    \r\n    let editable = One.getEdit(1) // or cuid.getEditable(item1);\r\n    Object.isFrozen(editable) // false\r\n    item === editable // false\r\n    \r\n    editable.text = \"test\"\r\n    One.put(editable)\r\n    \r\n    let edited = One.get(1)\r\n    edited.text = \"text\" // true\r\n    Object.isFrozen(edited) // true\r\n\r\nEditing an item changes all its instances in the cache:\r\n\r\n    let item = {uid:1}\r\n    let item2 = {uid:1, child:item}\r\n    One.put(item2)\r\n    One.get(1) === item // true\r\n    One.get(2) === item2 // true\r\n    \r\n    // Let's do some editing\r\n    let editable = One.getEdit(1);\r\n    editable.text = \"test\"\r\n    One.put(editable) // also updates item2 reference to item\r\n    \r\n    let result = One.get(2)\r\n    console.log(JSON.stringify(result.item)) // {uid:1, text:\"test\"}\r\n\r\n\r\n###Motivation\r\nMore an more applications are giving users the ability to edit data in the browser. \r\nWith a normalized data model various instances of an entity can exist at the same time in different locations. This depends on how data is received from the server and added to the local model / store. \r\n\r\nThis is inconvenient because: \r\n* Keeping all the instances in sync can be a daunting task. \r\n* It can make debugging hard. \r\n* It requires tracking each instance and makes reasoning about data complicated. \r\n* It can make the application structure needlessly complex.\r\n\r\n[Redux](https://github.com/reactjs/redux) brings a great breakthrough by putting the entire application state in one place and mutating it only via dispatched actions. But it doesn't enforce entity uniqueness. ```One``` aims to take the concept a step further by making each entity unique and immutable in a single store (cache).\r\n\r\n###Performance considerations\r\nYes there is a performance cost in analyzing each entity deeply to track its dependencies. ```One``` offers a couple of ways to mitigate this: **Read optimization** and **Queuing**. \r\n* **Read optimized**: the penalty is incurred on write operations only. These happen a lot less frequently than read ops. Read ops are super fast (a simple key lookup).\r\n* **Queuing** allows the developer to choose when to perform the write operation. ```One``` defers the write analysis when writing to the queue. The queue can commit between render operations. This way the UI remains fluid.   \r\nIf you were to track all instances of an entity on each update the write penalty could end up being comparably high. This is besides the added complexity introduced by such tracking management.\r\n\r\n###Data shape\r\nThis is not currently designed to work with cyclical data. It is best for non-cyclical objects received from the server in the form of json (or other non-cyclical fomats).  \r\nIf a strong need arises for managing cyclical structures this might be an option for future development.\r\n\r\n###Documentation\r\n* [Immutable data](https://maierson.gitbooks.io/one/content/immutable_data.html)\r\n* Api\r\n  * [Put](https://maierson.gitbooks.io/one/content/put.html)\r\n  * [Get](https://maierson.gitbooks.io/one/content/get.html)\r\n  * [Evict](https://maierson.gitbooks.io/one/content/evict.html)\r\n* [Threads](https://maierson.gitbooks.io/one/content/threads.html)\r\n* [Time travel](https://maierson.gitbooks.io/one/content/time_travel.html)\r\n\r\n    \r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}